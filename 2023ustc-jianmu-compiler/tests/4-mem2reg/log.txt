==========./functional-cases/0-io.cminus==========
Active Variable:
Insert PhiInst Done
globl function:main
%op0 = call i32 @input()
call void @output(i32 %op0)
ret i32 0
1234								1234
0								0
==========./functional-cases/1-return.cminus==========
Active Variable:
Insert PhiInst Done
globl function:main
call void @output(i32 111)
ret i32 111
111								111
111								111
==========./functional-cases/2-calculate.cminus==========
Active Variable:
op2: label_entry 
op1: label_entry 
op0: label_entry 
Insert PhiInst Done
globl function:main
%op6 = mul i32 25, 4
%op7 = add i32 23, %op6
ret i32 %op7
123								123
==========./functional-cases/3-output.cminus==========
Active Variable:
Insert PhiInst Done
globl function:main
call void @output(i32 11)
call void @output(i32 22222)
ret i32 0
11								11
22222								22222
0								0
==========./functional-cases/4-if.cminus==========
Active Variable:
op2: label_entry 
op1: label_entry 
op0: label_entry 
Insert PhiInst Done
globl function:main
%op5 = icmp sgt i32 11, 22
%op6 = zext i1 %op5 to i32
%op7 = icmp ne i32 %op6, 0
br i1 %op7, label %label8, label %label14
%op11 = icmp sgt i32 11, 33
%op12 = zext i1 %op11 to i32
%op13 = icmp ne i32 %op12, 0
br i1 %op13, label %label21, label %label23
%op17 = icmp slt i32 33, 22
%op18 = zext i1 %op17 to i32
%op19 = icmp ne i32 %op18, 0
br i1 %op19, label %label26, label %label28
ret i32 0
call void @output(i32 11)
br label %label25
call void @output(i32 33)
br label %label25
br label %label20
call void @output(i32 22)
br label %label30
call void @output(i32 33)
br label %label30
br label %label20
33								33
0								0
==========./functional-cases/5-while.cminus==========
Active Variable:
op1: label_entry label8 
op0: label_entry 
Insert PhiInst Done
globl function:main
br label %label2
%op13 = phi i32 [ 0, %label_entry ], [ %op11, %label8 ]
%op5 = icmp slt i32 %op13, 10
%op6 = zext i1 %op5 to i32
%op7 = icmp ne i32 %op6, 0
br i1 %op7, label %label8, label %label12
call void @output(i32 %op13)
%op11 = add i32 %op13, 1
br label %label2
ret i32 0
0								0
1								1
2								2
3								3
4								4
5								5
6								6
7								7
8								8
9								9
0								0
==========./functional-cases/6-array.cminus==========
Active Variable:
op1: label_entry 
Insert PhiInst Done
globl function:main
%op0 = alloca [10 x i32]
%op2 = icmp slt i32 0, 0
br i1 %op2, label %label6, label %label3
%op4 = getelementptr [10 x i32], [10 x i32]* %op0, i32 0, i32 0
store i32 11, i32* %op4
%op5 = icmp slt i32 4, 0
br i1 %op5, label %label10, label %label7
call void @neg_idx_except()
ret i32 0
%op8 = getelementptr [10 x i32], [10 x i32]* %op0, i32 0, i32 4
store i32 22, i32* %op8
%op9 = icmp slt i32 9, 0
br i1 %op9, label %label14, label %label11
call void @neg_idx_except()
ret i32 0
%op12 = getelementptr [10 x i32], [10 x i32]* %op0, i32 0, i32 9
store i32 33, i32* %op12
%op13 = icmp slt i32 0, 0
br i1 %op13, label %label19, label %label15
call void @neg_idx_except()
ret i32 0
%op16 = getelementptr [10 x i32], [10 x i32]* %op0, i32 0, i32 0
%op17 = load i32, i32* %op16
call void @output(i32 %op17)
%op18 = icmp slt i32 4, 0
br i1 %op18, label %label24, label %label20
call void @neg_idx_except()
ret i32 0
%op21 = getelementptr [10 x i32], [10 x i32]* %op0, i32 0, i32 4
%op22 = load i32, i32* %op21
call void @output(i32 %op22)
%op23 = icmp slt i32 9, 0
br i1 %op23, label %label28, label %label25
call void @neg_idx_except()
ret i32 0
%op26 = getelementptr [10 x i32], [10 x i32]* %op0, i32 0, i32 9
%op27 = load i32, i32* %op26
call void @output(i32 %op27)
ret i32 0
call void @neg_idx_except()
ret i32 0
11								11
22								22
33								33
0								0
==========./functional-cases/7-function.cminus==========
Active Variable:
op3: label_entry 
op2: label_entry 
Insert PhiInst Done
Active Variable:
op2: label_entry 
op1: label_entry 
op0: label_entry 
Insert PhiInst Done
globl function:min
%op6 = icmp sle i32 %arg0, %arg1
%op7 = zext i1 %op6 to i32
%op8 = icmp ne i32 %op7, 0
br i1 %op8, label %label9, label %label11
ret i32 %arg0
ret i32 %arg1
ret i32 0
globl function:main
%op5 = call i32 @min(i32 11, i32 22)
call void @output(i32 %op5)
%op8 = call i32 @min(i32 22, i32 33)
call void @output(i32 %op8)
%op11 = call i32 @min(i32 33, i32 11)
call void @output(i32 %op11)
ret i32 0
11								11
22								22
11								11
0								0
==========./functional-cases/8-store.cminus==========
Active Variable:
op5: label_entry 
op4: label_entry 
op3: label_entry 
Insert PhiInst Done
Active Variable:
op2: label16 label28 
op1: label_entry label8 label16 label28 
Insert PhiInst Done
globl function:store
%op8 = icmp slt i32 %arg1, 0
br i1 %op8, label %label13, label %label9
%op11 = getelementptr i32, i32* %arg0, i32 %arg1
store i32 %arg2, i32* %op11
ret i32 %arg2
call void @neg_idx_except()
ret i32 0
globl function:main
%op0 = alloca [10 x i32]
br label %label3
%op35 = phi i32 [ 0, %label_entry ], [ %op15, %label8 ]
%op5 = icmp slt i32 %op35, 10
%op6 = zext i1 %op5 to i32
%op7 = icmp ne i32 %op6, 0
br i1 %op7, label %label8, label %label16
%op9 = getelementptr [10 x i32], [10 x i32]* %op0, i32 0, i32 0
%op12 = mul i32 %op35, 2
%op13 = call i32 @store(i32* %op9, i32 %op35, i32 %op12)
%op15 = add i32 %op35, 1
br label %label3
br label %label17
%op36 = phi i32 [ 0, %label16 ], [ %op33, %label28 ]
%op37 = phi i32 [ 0, %label16 ], [ %op31, %label28 ]
%op19 = icmp slt i32 %op36, 10
%op20 = zext i1 %op19 to i32
%op21 = icmp ne i32 %op20, 0
br i1 %op21, label %label22, label %label26
%op25 = icmp slt i32 %op36, 0
br i1 %op25, label %label34, label %label28
call void @output(i32 %op37)
ret i32 0
%op29 = getelementptr [10 x i32], [10 x i32]* %op0, i32 0, i32 %op36
%op30 = load i32, i32* %op29
%op31 = add i32 %op37, %op30
%op33 = add i32 %op36, 1
br label %label17
call void @neg_idx_except()
ret i32 0
90								90
0								0
==========./functional-cases/9-fibonacci.cminus==========
Active Variable:
op1: label_entry 
Insert PhiInst Done
Active Variable:
op1: label_entry label8 
op0: label_entry 
Insert PhiInst Done
globl function:fibonacci
%op3 = icmp eq i32 %arg0, 0
%op4 = zext i1 %op3 to i32
%op5 = icmp ne i32 %op4, 0
br i1 %op5, label %label6, label %label7
ret i32 0
%op9 = icmp eq i32 %arg0, 1
%op10 = zext i1 %op9 to i32
%op11 = icmp ne i32 %op10, 0
br i1 %op11, label %label13, label %label14
ret i32 0
ret i32 1
%op16 = sub i32 %arg0, 1
%op17 = call i32 @fibonacci(i32 %op16)
%op19 = sub i32 %arg0, 2
%op20 = call i32 @fibonacci(i32 %op19)
%op21 = add i32 %op17, %op20
ret i32 %op21
br label %label12
globl function:main
br label %label2
%op14 = phi i32 [ 0, %label_entry ], [ %op12, %label8 ]
%op5 = icmp slt i32 %op14, 10
%op6 = zext i1 %op5 to i32
%op7 = icmp ne i32 %op6, 0
br i1 %op7, label %label8, label %label13
%op10 = call i32 @fibonacci(i32 %op14)
call void @output(i32 %op10)
%op12 = add i32 %op14, 1
br label %label2
ret i32 0
0								0
1								1
1								1
2								2
3								3
5								5
8								8
13								13
21								21
34								34
0								0
==========./functional-cases/10-float.cminus==========
Active Variable:
op2: label_entry 
op1: label_entry 
op0: label_entry 
Insert PhiInst Done
globl function:main
%op5 = fmul float 0x3ff19999a0000000, 0x3ff8000000000000
%op7 = fadd float %op5, 0x3ff3333340000000
call void @outputFloat(float %op7)
ret i32 0
2.850000							2.850000
0								0
==========./functional-cases/11-floatcall.cminus==========
Active Variable:
op4: label_entry 
op3: label_entry 
op2: label_entry 
Insert PhiInst Done
Active Variable:
op1: label_entry 
op0: label_entry 
Insert PhiInst Done
globl function:mod
%op7 = fdiv float %arg0, %arg1
%op8 = fptosi float %op7 to i32
%op12 = sitofp i32 %op8 to float
%op13 = fmul float %op12, %arg1
%op14 = fsub float %arg0, %op13
ret float %op14
globl function:main
%op4 = call float @mod(float 0x4026666660000000, float 0x40019999a0000000)
call void @outputFloat(float %op4)
ret i32 0
0.200000							0.200000
0								0
==========./functional-cases/12-global.cminus==========
Active Variable:
Insert PhiInst Done
Active Variable:
Insert PhiInst Done
Active Variable:
op1: label_entry label17 
op0: label_entry label11 label14 
Insert PhiInst Done
Active Variable:
op0: label_entry label6 
Insert PhiInst Done
globl function:randomLCG
%op0 = load i32, i32* @seed
%op1 = mul i32 %op0, 1103515245
%op2 = add i32 %op1, 12345
store i32 %op2, i32* @seed
%op3 = load i32, i32* @seed
ret i32 %op3
globl function:randBin
%op0 = call i32 @randomLCG()
%op1 = icmp sgt i32 %op0, 0
%op2 = zext i1 %op1 to i32
%op3 = icmp ne i32 %op2, 0
br i1 %op3, label %label4, label %label5
ret i32 1
ret i32 0
ret i32 0
globl function:returnToZeroSteps
br label %label2
%op27 = phi i32 [ 0, %label_entry ], [ %op29, %label26 ]
%op28 = phi i32 [ 0, %label_entry ], [ %op19, %label26 ]
%op4 = icmp slt i32 %op28, 20
%op5 = zext i1 %op4 to i32
%op6 = icmp ne i32 %op5, 0
br i1 %op6, label %label7, label %label10
%op8 = call i32 @randBin()
%op9 = icmp ne i32 %op8, 0
br i1 %op9, label %label11, label %label14
ret i32 20
%op13 = add i32 %op27, 1
br label %label17
%op16 = sub i32 %op27, 1
br label %label17
%op29 = phi i32 [ %op13, %label11 ], [ %op16, %label14 ]
%op19 = add i32 %op28, 1
%op21 = icmp eq i32 %op29, 0
%op22 = zext i1 %op21 to i32
%op23 = icmp ne i32 %op22, 0
br i1 %op23, label %label24, label %label26
ret i32 %op19
br label %label2
globl function:main
store i32 3407, i32* @seed
br label %label1
%op11 = phi i32 [ 0, %label_entry ], [ %op9, %label6 ]
%op3 = icmp slt i32 %op11, 20
%op4 = zext i1 %op3 to i32
%op5 = icmp ne i32 %op4, 0
br i1 %op5, label %label6, label %label10
%op7 = call i32 @returnToZeroSteps()
call void @output(i32 %op7)
%op9 = add i32 %op11, 1
br label %label1
ret i32 0
4								4
2								2
2								2
4								4
8								8
2								2
2								2
2								2
2								2
2								2
6								6
2								2
10								10
8								8
4								4
2								2
20								20
2								2
2								2
8								8
0								0
==========./functional-cases/13-complex.cminus==========
Active Variable:
op3: label_entry 
op2: label_entry 
Insert PhiInst Done
Active Variable:
op4: label51 label83 
op3: label_entry 
op2: label_entry 
Insert PhiInst Done
Active Variable:
op0: label_entry label54 
Insert PhiInst Done
globl function:max
%op6 = icmp sgt i32 %arg0, %arg1
%op7 = zext i1 %op6 to i32
%op8 = icmp ne i32 %op7, 0
br i1 %op8, label %label9, label %label11
ret i32 %arg0
ret i32 %arg1
ret i32 0
globl function:knapsack
%op6 = icmp sle i32 %arg1, 0
%op7 = zext i1 %op6 to i32
%op8 = icmp ne i32 %op7, 0
br i1 %op8, label %label9, label %label10
ret i32 0
%op12 = icmp eq i32 %arg0, 0
%op13 = zext i1 %op12 to i32
%op14 = icmp ne i32 %op13, 0
br i1 %op14, label %label15, label %label16
ret i32 0
%op18 = mul i32 %arg0, 11
%op20 = add i32 %op18, %arg1
%op21 = icmp slt i32 %op20, 0
br i1 %op21, label %label28, label %label22
%op23 = getelementptr [66 x i32], [66 x i32]* @dp, i32 0, i32 %op20
%op24 = load i32, i32* %op23
%op25 = icmp sge i32 %op24, 0
%op26 = zext i1 %op25 to i32
%op27 = icmp ne i32 %op26, 0
br i1 %op27, label %label29, label %label35
call void @neg_idx_except()
ret i32 0
%op31 = mul i32 %arg0, 11
%op33 = add i32 %op31, %arg1
%op34 = icmp slt i32 %op33, 0
br i1 %op34, label %label43, label %label40
%op38 = sub i32 %arg0, 1
%op39 = icmp slt i32 %op38, 0
br i1 %op39, label %label50, label %label44
%op41 = getelementptr [66 x i32], [66 x i32]* @dp, i32 0, i32 %op33
%op42 = load i32, i32* %op41
ret i32 %op42
call void @neg_idx_except()
ret i32 0
%op45 = getelementptr [5 x i32], [5 x i32]* @w, i32 0, i32 %op38
%op46 = load i32, i32* %op45
%op47 = icmp slt i32 %arg1, %op46
%op48 = zext i1 %op47 to i32
%op49 = icmp ne i32 %op48, 0
br i1 %op49, label %label51, label %label56
call void @neg_idx_except()
ret i32 0
%op53 = sub i32 %arg0, 1
%op55 = call i32 @knapsack(i32 %op53, i32 %arg1)
br label %label67
%op58 = sub i32 %arg0, 1
%op60 = call i32 @knapsack(i32 %op58, i32 %arg1)
%op62 = sub i32 %arg0, 1
%op65 = sub i32 %arg0, 1
%op66 = icmp slt i32 %op65, 0
br i1 %op66, label %label82, label %label74
%op93 = phi i32 [ %op55, %label51 ], [ %op87, %label83 ]
%op70 = mul i32 %arg0, 11
%op72 = add i32 %op70, %arg1
%op73 = icmp slt i32 %op72, 0
br i1 %op73, label %label92, label %label89
%op75 = getelementptr [5 x i32], [5 x i32]* @w, i32 0, i32 %op65
%op76 = load i32, i32* %op75
%op77 = sub i32 %arg1, %op76
%op78 = call i32 @knapsack(i32 %op62, i32 %op77)
%op80 = sub i32 %arg0, 1
%op81 = icmp slt i32 %op80, 0
br i1 %op81, label %label88, label %label83
call void @neg_idx_except()
ret i32 0
%op84 = getelementptr [5 x i32], [5 x i32]* @v, i32 0, i32 %op80
%op85 = load i32, i32* %op84
%op86 = add i32 %op78, %op85
%op87 = call i32 @max(i32 %op60, i32 %op86)
br label %label67
call void @neg_idx_except()
ret i32 0
%op90 = getelementptr [66 x i32], [66 x i32]* @dp, i32 0, i32 %op72
store i32 %op93, i32* %op90
ret i32 %op93
call void @neg_idx_except()
ret i32 0
globl function:main
store i32 5, i32* @n
store i32 10, i32* @m
%op1 = icmp slt i32 0, 0
br i1 %op1, label %label5, label %label2
%op3 = getelementptr [5 x i32], [5 x i32]* @w, i32 0, i32 0
store i32 2, i32* %op3
%op4 = icmp slt i32 1, 0
br i1 %op4, label %label9, label %label6
call void @neg_idx_except()
ret i32 0
%op7 = getelementptr [5 x i32], [5 x i32]* @w, i32 0, i32 1
store i32 2, i32* %op7
%op8 = icmp slt i32 2, 0
br i1 %op8, label %label13, label %label10
call void @neg_idx_except()
ret i32 0
%op11 = getelementptr [5 x i32], [5 x i32]* @w, i32 0, i32 2
store i32 6, i32* %op11
%op12 = icmp slt i32 3, 0
br i1 %op12, label %label17, label %label14
call void @neg_idx_except()
ret i32 0
%op15 = getelementptr [5 x i32], [5 x i32]* @w, i32 0, i32 3
store i32 5, i32* %op15
%op16 = icmp slt i32 4, 0
br i1 %op16, label %label21, label %label18
call void @neg_idx_except()
ret i32 0
%op19 = getelementptr [5 x i32], [5 x i32]* @w, i32 0, i32 4
store i32 4, i32* %op19
%op20 = icmp slt i32 0, 0
br i1 %op20, label %label25, label %label22
call void @neg_idx_except()
ret i32 0
%op23 = getelementptr [5 x i32], [5 x i32]* @v, i32 0, i32 0
store i32 6, i32* %op23
%op24 = icmp slt i32 1, 0
br i1 %op24, label %label29, label %label26
call void @neg_idx_except()
ret i32 0
%op27 = getelementptr [5 x i32], [5 x i32]* @v, i32 0, i32 1
store i32 3, i32* %op27
%op28 = icmp slt i32 2, 0
br i1 %op28, label %label33, label %label30
call void @neg_idx_except()
ret i32 0
%op31 = getelementptr [5 x i32], [5 x i32]* @v, i32 0, i32 2
store i32 5, i32* %op31
%op32 = icmp slt i32 3, 0
br i1 %op32, label %label37, label %label34
call void @neg_idx_except()
ret i32 0
%op35 = getelementptr [5 x i32], [5 x i32]* @v, i32 0, i32 3
store i32 4, i32* %op35
%op36 = icmp slt i32 4, 0
br i1 %op36, label %label40, label %label38
call void @neg_idx_except()
ret i32 0
%op39 = getelementptr [5 x i32], [5 x i32]* @v, i32 0, i32 4
store i32 6, i32* %op39
br label %label41
call void @neg_idx_except()
ret i32 0
%op59 = phi i32 [ 0, %label38 ], [ %op57, %label54 ]
%op43 = icmp slt i32 %op59, 66
%op44 = zext i1 %op43 to i32
%op45 = icmp ne i32 %op44, 0
br i1 %op45, label %label46, label %label50
%op47 = sub i32 0, 1
%op49 = icmp slt i32 %op59, 0
br i1 %op49, label %label58, label %label54
%op51 = load i32, i32* @n
%op52 = load i32, i32* @m
%op53 = call i32 @knapsack(i32 %op51, i32 %op52)
call void @output(i32 %op53)
ret i32 0
%op55 = getelementptr [66 x i32], [66 x i32]* @dp, i32 0, i32 %op59
store i32 %op47, i32* %op55
%op57 = add i32 %op59, 1
br label %label41
call void @neg_idx_except()
ret i32 0
15								15
0								0
